<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">


    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부내용 정리 블로그" />
    <link rel="shortcut icon" href="https://pathfinder357.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://pathfinder357.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Pathfinder practice blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="공부내용 정리 블로그" />
    <meta property="og:url" content="https://pathfinder357.github.io/search" />
    <meta property="og:image" content="https://pathfinder357.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="공부내용 정리 블로그" />
    <meta name="twitter:url" content="https://pathfinder357.github.io/" />
    <meta name="twitter:image" content="https://pathfinder357.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Pathfinder practice blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Pathfinder practice blog",
        "logo": "https://pathfinder357.github.io/"
    },
    "url": "https://pathfinder357.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://pathfinder357.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://pathfinder357.github.io/search"
    },
    "description": "공부내용 정리 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://pathfinder357.github.io/">Pathfinder practice blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-data-structure" role="menuitem"><a href="/tag/data-structure/">data-structure</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">algorithm</a></li>
    <li class="nav-blockchain" role="menuitem"><a href="/tag/blockchain/">blockchain</a></li>
    <li class="nav-ai" role="menuitem"><a href="/tag/ai/">ai</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "hash-table": {
        "title": "자료구조 (7) 해시 테이블",
            "author": "pathfinder357",
            "category": "",
            "content": "Hash Table  해시 테이블은 일종의 사전이고, Python 의 dict 자료구조처럼 다음 연산을 빠르게 지원          if(데이터가 key, value 값의 쌍으로 구성                  insert(key, val)     #(key, val)를 해시 테이블에 저장, 같은 키가 있다면 overwirte          remove(key, val)     #(key, val)가 해시 테이블에 있다면 제거(delete)          search(key)          #(key, val)를 찾아 리턴, 없다면 알려줌                          해시 테이블은 보통 정보를 담아 저장할수있는 서랍장 행태로 구현          가장 핵심적인 과정은 각 정보를 몇번째 서랍에 넣을지를 결정하는 것        정보 K(key)가 저장될 서랍장(slot) 번호를 계산하는 함수 f()를 hash func 이라 한다.hash func  만약 key값이 정수가 아니라면?&gt; 실수이거나 문자열이라면?                  (실수, 문자열) key 값을 정수에 대응시키는 prehash함수를 먼저 사용해 변환                    hash 함수로 지정할수 있음                  perpect 해시 함수: 충돌없이 1 - to - 1 매핑하는 해시 함수        c- universal 해시 함수: 서로 임의의 두 key 값 x, y 에대해 prob(f(x) == f(y)= c/size(H))  이 성립하는 해시 함수    (key 값이 숫자일 경우)          Division: f(k) = (k mod p) mod m(p:소수)                  key 값들의 성질이 잘 알려지지 않은 경우                    Multiplication: f(k) = ((ak) mod 2^w) » (w-r)                  a:랜덤값, w =log k, r=log m                    folding: key값들의 digit을 나눠 연산하는 방식                  shift - folding: ex) bank- account k = 1234 - 567 - 601 두개의 digit 씩 나눠 모두  더한다 -&gt; (12+ 34+ 56+ 76+ 01) mod m                    mid - square : key 값을 적당히 연산후 , 그결과의 중간부분을 떼어내 주소로 사용                  m= 1000이고, k= 3121이면, 3121 ^2 = 9740641이되고 중간에 3 digit을 때어낸 주소 406                    Extraction: key 값의 각 파트마다 임의의 digit을 떼어네 연결해 계산                  계좌번호가 1254-387-601이라면, 1254에서 12, 601에서 1을 때어낸후 서로 붙여 121을 만듬                          (key 값이 string 경우)          Additive hash: key[i]의 단순 합      Rotating hash: «, »(비트 쉬프트)연산과 ^(exclusive or) 연산을 반복        좋은 해시 함수란?          되도록 빠르고, 충돌이 되도록 적어야 한다.      충돌 해결 방법  서로 다른 key 값 x, y에 대해 f(x) = f(y)가 된다면 두 키값은 충돌이라함  이와 같은 경우에 두값을 해시 테이블에 저장 방법 즉 충돌 해경방법 필요  open - addressing 과 chaining 두가지 방법이 일반적임a. open addressing: linear probing  삽입 탐색 pseudo code ↓def set(key, val):   i = find_slot(key)      #빈 슬롯이 없는 경우 대책은?   if i == FULL:           #더 큰 테이블이 필요함.      return None   if H[i] is occupied:    #key값이 존재하면 기존 값 수정      H[i].val = val       #val 값 update 후 리턴   else:                   #H[i]가 비어있는 경우, 즉 key가 없다면 새로 지정해야함      H[i].key =key      H[i].val = val   retrun keydef find_slot(key):   i = f(key)   start = i   while (H[i] is occupied) and (H[i].key != key):      i = (i+1) % m      if i == start:          return FULL      return i  삽입 연산: set(key, val)          해시 테이블 H의 각 슬롯에는 하나의 아이템을 저장      아이템(key , val) 쌍으로 정의      key는 아이템들끼리 구분하므로 아이템마다 서로 달라야함      value 는 해당 아이템의 다양한 정보를 의미      key 값을 갖는 아이템이 이미 테이블에 있다면 해당 아이템의 val를 매개변수 val값으로 수정, 없다면 새 아이템(key, val)를 삽입하는 연산      정상적으로 삽입이 이루어지면, key 값을 그대로 리턴하고, 빈테이블에 빈슬롯이 없어 삽입하지 않으면 FULL 리턴      이를 위해 open addressing 방법에 따라 key값을 갖는 아이템을 찾거나 빈슬롯을 찾아 H인덱스를 리턴하는 find_slot(key)함수 필요        find_slot(key)          key 값을 갖는 아이템을 찾아 index를 리턴. 단 해당 슬롯에 아이템 있다면 key 값을 갖는 아이템이며, 슬롯이 비어있다면 해당 아이템이 해시 테이블에 없다는 뜻      만약 key 값을 갖는 슬롯이 존재하지도, 빈슬롯도 없다면 FULL리턴        삭제 psuedo code ↓    def remove(key):  i =find_slot(key)  if H[i] is unoccupied:      return None  j = i  while True:      mark H[i] as unoccupied      while True:          j = (j+1) % m           if H[j] is unoccupied:  # 이동완료              return key          k = f(H[j].key)          if not(i &lt; k &lt;= j or j &lt;i&lt; k or k&lt;=j &lt;i):              break      H[i] = H[j]      i = j        삭제 연산: remove(key)          key 값을 갖는 아이템을 find_slot()을 이용해 찾는다.      H[i]가 비었다면 삭제할 아이템이 실제로 존재 하지않으므로 None 리턴      H[i]가 존재한다면, 이 아이템때문에 밀린 아래쪽의 cluster 들을 연쇄적으로 위로 올려 이동한다      이동한후 성공적인 삭제가 수행되었다는 의미에서 key 값 자체 리턴                  H[i]는 현재 빈슬롯이고, 아래쪽 H[j]에 있는 아이템을 H[i]로 이동할지를 결정해야 함          H[j].key 값의 해시 함수 값을 k 라 하자 즉, k = f(H[j].key)이다          이 키 값이 [i,j]에 있다면 즉, (..i..k..j..)순이라면 H[j]를 H[i]로 옮기면 안됨          왜?? -&gt;                    ",
        "url": "/hash-table"
    }
    ,
    
    "data-queue": {
        "title": "자료구조 (4) 큐",
            "author": "pathfinder357",
            "category": "",
            "content": "QueueFIFO(first-in first-out)규칙의 순차적 자료구조자료를 추가 / 삭제하는 통상적으로 합의한 용어insert -&gt; enqueuedelete -&gt; dequeue이런식으로 작동할려면 어떻게 해야할까?stack은 어디까지 쌓여있는지에 대한 정보 즉 top()에 있는 값의 인덱스만 가지고 작동을 다루었다면queue는 1.enqueue는 차곡차곡 쌓여서 어디까지 쌓여있는지2.dqueue 가장 밑에 있는 다음에 나갈 값이 어디 인덱스가 있는지 즉 두개의 인덱스 이 두개로 문제를 해결.여기서 주의할점은 dequeue를 한다고 해서 실제로 값이 삭제되는 것이 아니고index를 조절하는것일 뿐이다.큐 설계class Queue:    def __init__(self):        self.items = []        self.front_index = 0        self.size =0    def enqueue(self, val):        self.items.append(val)        self.size += 1        def dequeue(self):        if self.front_index == len(self.items):            print('Queue is empty')            return None        else:            x = self.items[self.front_index]            self.front_index += 1            self.size -= 1            self.items.pop(0)            return x    def size(self):        return len(self.size)Josephus Problemfrom stack_queue import Queuedef rullet(n,k):    Q=Queue()    for cnt in range(1, n+1):        Q.enqueue(cnt)    while Q.size !=0:        for i in range(1,k):            Q.enqueue(Q.dequeue())        Q.pop()    return Q.dequeue()",
        "url": "/data-queue"
    }
    ,
    
    "data-array-list": {
        "title": "자료구조 (1) 어레이와 리스트 차이",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     1    2    3    4    5    6    7배열과 리스트일반적인 프로그램 동작 방식A[2]    =      A[2]   +  1(쓰기)  (대입)  (읽기)   (산술)파이썬은 씨언어의 배열의 셀과 다르게 데이터의가 저장된곳의 주소가 저장된다.즉 항상 객체의 주소만 저장하기때문에, 리스트의 셀의 크기를 메모리의 주소를 표현 할수있는 8바이트로 고정하면 된다.모든셀의 크기가 같기 때문에 index에 의해 O(1)시간 접근이 가능하다.C는 배열에 읽기와 쓰기만 적용되지만 파이썬의 리스트는 pop, insert, append등 여러가지 연산이 추가되는 굉장히 편리리스트는 용량을 자동조절(동적배열)ex) def append principle of operation(Pseudo code)def append(A, val):1. if A.capacity == A.n:  #needed to resize!!    a. 더큰 메모리를 가진 리스트 B를 할당하고 B.capacity 와 B.n으로 갱신하자      b. for i in range(A, n):        B[i] = A[i]    c. dispose A    d. A = B2. A[n] = val3. A.n += 1리스트가 가지는 강력한 동작들1.append(val) : #맨 오른쪽(뒤)에 새로운 값 val를 삽입2.A.pop(i): #A[i]값을 지운후 리턴(i의 오른쪽 값들은 왼쪽으로 한칸씩 당겨져 cell의 수 감소)3.A.insert(i ,val) : val 연산( 단 A[i] , A[i+1], .. 값들은 오른쪽으로 한칸씩 이동해 A[i]를 비운후 , val 값 저장)4.A.remove(val) : val값 제거5.A.index(val) : val 값이 처음으로 등장하는 index 리턴6.A.count(val) : val값이 몇번 등장하는 지 횟수를 세어 리턴7.A[i:j] : A[i], ..., A[j-1]까지를 복사해 새로운 리스트 생성하여 리턴(slicing 연산)8.val in A : 맴버십 연산자 -A에 val가 있으면 True, 없으면 False",
        "url": "/data-array-list"
    }
    ,
    
    "data-stack": {
        "title": "자료구조 (3) stack",
            "author": "pathfinder357",
            "category": "",
            "content": "stack__init(self) : 생성함수def __init__(self):        self.items = []ex)S= Stack()init 생성함수안 에있는 객체인 self.itmes = []가 자동으로 생성try &amp; except : try 블록에 있는것을 수행하다가 수행중 에러가 나오면 except에 있는 statment를 수행def pop(self):        try:            return self.items.pop()        except IndexError:            print('stack is empty')print(len(S)) len 을 수행하면 class Stack 안에 있는 len 안에 있는 statement를 수행def __len__(self):        return len(self.items)stack 안에 수행되는 함수들은 전부 O(1) 상수시간안에 돌아가는 자료구조이다.prac) 괄호 맞추기  (2 + 5) * 7 -((3-1)/2+7)  ( ( ) ( ) )  ( ( ) ) ) (    &lt;- 적당한 쌍이 아님-문제:입력: 왼쪽 오른쪽 괄호의 문자열출력: 괄호쌍이 맞춰져있으면 True or False관찰:……(…….)……ex1)( ( ) ( ) )1 2 2 3 3 1왼쪽부터 차례로 읽으면(1) 왼쪽 괄호 ( 왼쪽 괄호가 들어가면 기다려야 하므로 pushex2)( ) )ex3)( ) (알고리즘for p in parseq:    if p =='(' :         S.push(p)    elif p == ')' :         S.pop()  # error 오른쪽이 더 많음    else:         print('Not allowed Symbol)    if len(S) &gt; 0:         return False  # error 왼쪽이 더많음    else:         retun True전체 소스 코드class Stack:    def __init__(self):        self.items = []        def push(self, val):        self.items.append(val)        def pop(self):        try:            return self.items.pop()        except IndexError:            print('stack is empty')        #가장 맨위에 있는 값을 리턴        def top(self):        try:            return self.items[-1]        except IndexError:            print('stack is empty')        #stack의 item수 반환    def size(self):        return len(self.items)        def paresq(self, p):        for p in self.items:            if p == '(':                self.push(p)            elif p == ')':                print('doing pop')                self.pop(p)            else:                print('not allowed Symbol')        if self.__len__() &gt; 0:            return False        else:            return True  postfix 변환기from stack_queue import Stackdef postfix_op(x):    s = Stack()    outstack=[]    priority = {        '*':3,        '/':3,        '+':2,        '-':2,        ')':4,        '(':1    }    for token in x:        if token not in '+-*/()':            outstack.append(token)        elif token == '(':            s.push(token)        elif token == ')':            while s.top() != '(':                outstack.append(s.pop())            s.pop()        else:            if s.is_empty():                s.push(token)            else:                while s.size() &gt; 0:                    if priority[s.top()] &gt;= priority[token]:                        outstack.append(s.pop())                    else:                        break                s.push(token)    while not s.is_empty():        outstack.append(s.pop())    return outstack###postfix 계산기(int일 경우에만)def calc(x):    s2= Stack()    for token in x:        if token not in '+-*/':            s2.push(token)        elif token =='+':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b+a)        elif token =='-':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b-a)        elif token =='*':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b*a)         elif token =='/':            a=int(s2.pop())            b=int(s2.pop())            s2.push(int(b/a))    return int(s2.pop())",
        "url": "/data-stack"
    }
    ,
    
    "data-tree": {
        "title": "자료구조 (6) 트리",
            "author": "pathfinder357",
            "category": "",
            "content": "프로그래밍 자료구조 마지막장 트리.LCRS 트리class Node:    def __init__(self, data):        self.data= data        self.left= None        self.right= None        def __str__(self):        return str(self.data)# __init__을 불러 데이터, 왼쪽 자식, 오른쪽 형제를 초기화하고 __str__을 사용해서 반환된 문자열 표현class Tree:    def __init__(self):        self.root = None    def preorderTraversal(self, node):        print(node, end='')         if not node.left == None :             self.preorderTraversal(node.left) #left_node가 비어있지 않으면 left_node 호출         if not node.right == None :             self.preorderTraversal(node.right) #right_node가 비어있지 않으면 자기호출    def inorderTraversal(self, node):        if not node.left == None : self.inorderTraversal(node.left)        print(node, end='')        if not node.right == None : self.inorderTraversal(node.right)        def postorderTraversal(self, node):        if not node.left == None : self.postorderTraversal(node.left)        if not node.right == None : self.postorderTraversal(node.right)        print(node, end='')    def makeRoot(self, node, left_node, right_node):        if self.root ==None:            self.root=node        node.left=left_node        node.right=right_nodeif __name__==\"__main__\":    node =[]    node.append(Node('-'))     node.append(Node('*'))     node.append(Node('/'))     node.append(Node('A'))    node.append(Node('B'))    node.append(Node('C'))    node.append(Node('D'))     m_tree =Tree()    for i in range(int(len(node)/2)):        m_tree.makeRoot(node[i],node[i*2+1],node[i*2+2])    print(      '전위 순회: ',end=''); m_tree.preorderTraversal(m_tree.root)    print('\\n'+ '중위 순회: ',end=''); m_tree.inorderTraversal(m_tree.root)    print('\\n'+ '후위 순회: ',end=''); m_tree.postorderTraversal(m_tree.root)    이진트리class Node:    def __init__(self,data):        self.data = data        self.left = None        self.right= None        self.is_thread_right = None    def __str__(self):        return str(self.data)class ThreadTree:    def __init__(self):        self.root = None        def inorderTraversal(self, node):        while not node.left ==None:            node = node.left        print(node, end='')        while True:            node = self.findThread(node)            print(node, end='')            if node.right == None:                break    def findThread(self, node):        pre_node = node        node = node.right        if node == None:            return node        if pre_node.is_thread_right:            return node        while not node.left == None:            node = node.left        return node    def makeRoot(self, node, left_node, right_node, thread):        if self.root == None:            self.root = node        node.left = left_node        node.right= right_node        node.is_thread_right = threadif __name__ == \"__main__\":    node =[]    node.append(Node('-'))    node.append(Node('*'))    node.append(Node('/'))    node.append(Node('A'))    node.append(Node('B'))    node.append(Node('C'))    node.append(Node('D'))    m_tree = ThreadTree()    for i in range(int(len(node)/2)):        m_tree.makeRoot(node[i],node[i*2+1],node[i*2+2],False)    m_tree.makeRoot(node[3],None, None, True)    m_tree.makeRoot(node[4],None, None, True)    m_tree.makeRoot(node[5],None, None, True)    node[3].right =node[1]    node[4].right= node[0]    node[5].right= node[2]    print('중위 순회: ', end='' ) ; m_tree.inorderTraversal(m_tree.root) 수식 트리class Node:    def __init__(self,data):        self.data=data        self.left=None        self.right=None    def __str__(self):        return str(self.data)class Express_Tree:    def __init__(self):        self.root =None    def makeRoot(self, node, left_node, right_node):        if self.root == None : self.root=node        node.left= left_node        node.right = right_node    def preorderTraversal(self, node):        print(node, end='')        if not node.left == None : self.preorderTraversal(node.left)        if not node.right == None : self.preorderTraversal(node.right)    def inorderTraversal(self, node):        if not node.left == None : self.inorderTraversal(node.left)        print(node, end='')        if not node.right == None : self.inorderTraversal(node.right)    def postorderTraversal(self, node):        if not node.left == None : self.postorderTraversal(node.left)        if not node.right == None : self.postorderTraversal(node.right)        print(node, end='')class expression:    def switch(self, arg):        self.case_name = 'case_' + str(arg)        self.case= getattr(self, self.case_name, lambda: )if __name__ == \"__main__\":    node =[]    node.append(Node('/'))    node.append(Node('*'))    node.append(Node('7'))    node.append(Node('1'))    node.append(Node('-'))    node.append(Node('5'))    node.append(Node('2'))분리집합 트리class DisjoinSet:    def __init__(self, n):        self.data = [-1 for _ in range(n)]        self.size = n    def find(self, index):        value= self.data[index]        if value &lt;0:            return index                return self.find(value)    def union(self, x, y):        x = self.find(x)        y = self.find(y)        if x == y:            return                if self.data[x] &lt; self.data[y]:            self.data[x] += self.data[y]            self.data[y] = x        else:            self.data[y] += self.data[x]            self.data[x] = y                self.size -= 1disjoint = DisjoinSet(10)disjoint.union(0,1)disjoint.union(1,2)disjoint.union(2,3)disjoint.union(4,5)disjoint.union(5,6)disjoint.union(6,7)disjoint.union(8,9)print(disjoint.data)print(disjoint.size) ",
        "url": "/data-Tree"
    }
    ,
    
    "data-list": {
        "title": "자료구조 (5) 링크드리스트",
            "author": "pathfinder357",
            "category": "",
            "content": "목록형 자료구조인 리스트를 통해 자료구조의 기초를 다질것입니다.링크드 리스트링크드 리스트는 한방향 리스트와 양방향 리스트가 있다.1.링크드리스트는 파이썬의 리스트와 이름만 비슷하지 다른 개념이다.      파이썬의 리스트는 C의 array와 유사한 개념으로 index를 통해 접근하고 수정한다.        링크드 리스트는 노드가 링크에 의해 기차처럼 연결된 순차 자료구조로 링크를 따라 원하는 노드의 데이터를 접근하고 수정한다.  2.노드: 실제 값을 위한 data정보(보통 key값을 저장)와 인접노드를 연결하는 link로 구성class Node:    def __init__(self, key=None):        self.key = None        self.next =None          노드는 자료와 다음 노드를 가르키는 참조값으로 구성 됩니다.3.한방향 링크드 리스트구현하고자 하는 방식노드 생성(structure) -&gt; 노드 추가-&gt; 노드 탐색-&gt; 노드 삭제-&gt; 노드 삽입-&gt;노드수 세기class SLL:    def __init__(self):        self.head =None        self.size = 0    def __iter__(self):        v = self.head        while v != None:            yield v        v = v.next    def __str__(self):        return \"-&gt;\".join(str(v) for v in self)여기서 iterator &amp; generator 개념에 대해서 잠깐 짚고 가보자iterator란?  리스트, 집합, 딕셔너리와 같은 타입이나, 문자열은 for -in 구문을 통해서 “반복적”으로 하나씩 데이터를 꺼내서 처리할수있다.                  이와 같이 여러개의 데이터를 포함한 타입중에서 반복적으로 하나하나 꺼내어 처리가능한 컬랙션이나sequence 들을 순환가능(iterable) 객체라고 한다.                    iterator는 next()함수를 구현한 객체를 말하며 next()함수는 순환가능한 객체의 다음 원소 반환                  파이썬의 iterable 형: list, dict, set, bytes, tuple, range        iter()함수: iterable 형 객체를 iterator 객체로 만드는 파이썬 내장함수    next() 함수를 이용해서 iterator 객체의 다음요소를 얻는데 만약 더이상 가져올 객체가없을경우 StopIteration 예외를 발생시킨다.generator 란?  제너레이터 객체는 모든 값을 메모리에 올려두고 이용하는 것이 아니라 필요할 때마다 생성해서 반환하는 일을함ex)my_generator = (x for x in range(1,4))for n in my_generator:    print(n)123type(my_generator)&lt;class generator&gt;이와같이 반복자와 동일한 일을 하는것처럼 보이지만 여기에서 생성된 1,2,3을 미리 메모리에 만드는것이 아니라 for문에 필요로 할때마다 my_generator로 부터 받아오며 메모리에서 보관하지 않는 점이다. 이를 lazy evaluation이라 함  yield                  일반적인 함수의 return문과 유사하지만 제너레이터를 반환한다는 점에서 return과 차이가 있다.                    여기서 return 문과 yield 개념에 대해서 정리해보자 확실한 비교를 위해서                    return 은 로컬변수로서 함수가 값을 반환할때 사라진다.                    yield 은 로컬변수가 함수를 빠져나올때 throw away 한후에도 값을 그대로 지님즉 함수를 완전히 끝내는게 아니라 필요할때마다 돌려주는 것이다 즉 함수를 실행하면서 바깥에다 값을 던지는것                    yield 바로 밑의 sentence 를 실행                    주의사항: 제너레이터는 실행할때 함수의 몸체를 실행하는것이 아니라, 제너레이터 함수가 가진 객체를 반환하는 일을한다.                    제너레이터는 한번 생성해서 반환한 객체를 보관하지 않기때문에 이전의 코드를 실행한수 추가한 코들르 실행하면 아무런 객체도 출력되지 않음                    제너레이터는 한번 실행하면 아무것도 반환하지않음            class Node:    def __init__(self, data, next=None):        self.data = data        self.next = nextclass SList:    def __init__(self):        self.head = Node(next)        self.size = 0            def listSize(self):        return self.size        def is_empty(self):        if self.size != 0:            return False        else:            return True            def selectNode(self, idx):        if idx &gt;= self.size:            print(\"Index Error\")            return None        if idx == 0:            return self.head        else:            tail = self.head            for cnt in range(idx):                tail = tail.next            return tail            def appendleft(self, value):        if self.is_empty():            self.head = Node(value)        else:            self.head = Node(value, self.head)        self.size += 1        def append(self, value):        if self.is_empty():            self.head = Node(value)            self.size += 1        else:            tail = self.head            while tail.next != None:                tail = tail.next            newtail = Node(value)            tail.next = newtail            self.size += 1            def insert(self, value, idx):        if self.is_empty():            self.head = Node(value)            self.size += 1        elif idx == 0:            self.head = Node(value, self.head)            self.size += 1        else:            tail = self.selectNode(idx-1)            if tail == None:                return            newNode = Node(value)            tmp = tail.next            tail.next = newNode            newNode.next = tmp            self.size += 1            def delete(self, idx):        if self.is_empty():            print('Underflow: Empty Linked List Error')            return        elif idx &gt;= self.size:            print('Overflow: Index Error')            return        elif idx == 0:            tail = self.head            self.head = tail.next            del(tail)            self.size -= 1        else:            tail = self.selectNode(idx-1)            deltarget = tail.next            tail.next = tail.next.next            del(deltarget)            self.size -= 1                def printlist(self):        target = self.head        while target:            if target.next != None:                print(target.data, '-&gt; ', end='')                target = target.next            else:                print(target.data)                target = target.next공부하던 와중 가장 햇갈린 부분 삽입 부분에서 밑의 코드    tail= self.head    while tail.next != None:        tail = tail.next    newtail=Node(value)    tail.next = newtail    self.size +=1이부분은 노드추가 함수 부분중 일부분인데 노드 추가하기 위해서 꼬리 노드에 도달하면 마지막 노드의 .next에 새로운노드의 주소를 저장하고 size를 추가시키는 부분인데while 반복문중에서 tail = tail.next 이부분이 이해가 잘 가지가 않았다. 하지만 공부했던 것을 다시 생각해보니 좌변에 있는 변수는 우변에 있는 어떤것에 대한 주소의 별칭일 뿐이다.즉 tail =tail.next는 tail이 가르키는 곳이 tail.next가 가르키는 곳으로 바뀌었다는 뜻인것이다.splice 연산def splice(self, a, b, x):  조건1: a -&gt;.... -&gt; b  조건2: a와 b 사이에 (Head노드 X, x노드존재 X) cut될경우 다른노드로 올기다는뜻이됨   조건3: 조건 1,2가 유지 된다면 a~b사이만큼을 노드를 컷  조건4: x-&gt;x.next 사이에 붙여넣기  ",
        "url": "/data-list"
    }
    ,
    
    "data-basic": {
        "title": "자료구조 (2) 순차적자료구조",
            "author": "pathfinder357",
            "category": "",
            "content": "순차적 자료구조(1) 배열, 리스트인덱스로 임의 원소를 접근  연산자 []  삽입(append, insert)  삭제(pop, remove)(2) stack, queue, dequeue  제한된 접근(삽입, 삭제)  접근만 허용  배열과 리스트는 인덱스만 알면 삭제 삽입이 가능하지만 스택, 큐는 제한된 것만 활용가능＊ 스택 접근 방식  LIFO(last in first out)밑에서부터 차곡차곡제한된 연산만 사용하는 자료구조는 굉장히 많다 (ex: )＊ 큐 접근방식  FIFO(first in fist out, 선착순)밑에서부터 차곡차곡＊ dequeue 접근방식  stack + queue(3) Linked List독립적으로 저장되어 있는 노드에 다음값에 대해서 알고있는 링크를연결 하는 것      각각의 노드에 자기 자신의 val + self.next를 가진다.        각자의 값들이 연속되어 있지 않은 곳에 저장되어 있고 다음 노드의 링크를 가지고있는것(idx로 접근 할수가없지만 함수로 가능케 할순있음)  ",
        "url": "/data-basic"
    }
    ,
    
    "algo-control": {
        "title": "second",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     first    second컨트롤# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           yujunchoi  avatar:         photo.jpg  bio:            &quot;SSU computer science lab&quot;  email:          nsa01775@naver.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://pathfinder357.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: CYJ practice blog# 자신의 blog title.description: 공부내용 정리 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.png# favicon으로 사용할 imageproduction_url: https://pathfinder357.github.io# 최종적으로 blog가 운영될 urlsource_url: https://github.com/pathfinder/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: pathfinder357repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ../[GitHubPage]/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera  - _posts/python  - _posts/typescript  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy",
        "url": "/algo-control"
    }
    ,
    
    "algo-basic": {
        "title": "first",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     first    second알고리즘알고리즘은 문제의 입력을 수학적이고 논리적으로 정의된 연산과정을 거쳐 원하는 출력을 계산하는 절차이고, 이절차를 c나 python과 같은 언어로 표현하는 프로그램또는 코드가 된다.입력은 (array(C) 또는 list(Python)), 연결리스트, 트리, 해시테이블, 그래프와 같은 자료의접근과 수정이 빠른 자료구조에 저장된다.최초의 알고리즘인 GCD를 재귀를 이용하여 구현한 코드를 짜보았다.def algo_gcd(a,b):while a*b != 0:if a&gt;b:a = a - balgo_gcd(b ,a % b)else:b = b- aalgo_gcd(a, b % a)        return a + bprint(algo_gcd(22,13))",
        "url": "/algo-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://pathfinder357.github.io/">Pathfinder practice blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search Pathfinder practice blog</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
