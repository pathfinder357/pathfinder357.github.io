<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">


    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부내용 정리 블로그" />
    <link rel="shortcut icon" href="https://pathfinder357.github.io/assets/built/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://pathfinder357.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Pathfinder practice blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="공부내용 정리 블로그" />
    <meta property="og:url" content="https://pathfinder357.github.io/search" />
    <meta property="og:image" content="https://pathfinder357.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="공부내용 정리 블로그" />
    <meta name="twitter:url" content="https://pathfinder357.github.io/" />
    <meta name="twitter:image" content="https://pathfinder357.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Pathfinder practice blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Pathfinder practice blog",
        "logo": "https://pathfinder357.github.io/"
    },
    "url": "https://pathfinder357.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://pathfinder357.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://pathfinder357.github.io/search"
    },
    "description": "공부내용 정리 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://pathfinder357.github.io/">Pathfinder practice blog</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-data-structure" role="menuitem"><a href="/tag/data-structure/">data-structure</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">algorithm</a></li>
    <li class="nav-blockchain" role="menuitem"><a href="/tag/blockchain/">blockchain</a></li>
    <li class="nav-ai" role="menuitem"><a href="/tag/ai/">ai</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "blockchain-1": {
        "title": "블록체인 (1)",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     first비트코인 네트워크의 개요비트코인의 탄생중앙집권적인 정부나 기업이 개인의 프라이버시를 보장해 주지 못하므로 암호 기술을 이용해 스스로 프라이버시를 보호하기 위해 탄생사토시 나가모토라는 익명의 저자가 쓴 한편의 논문에서 시작 됫으며 이논문은 탈중앙화된 화폐시스템을 제안이 논문의 주요 제안 내용은 이와 같다  중앙통제시스템이 없는 탈중앙화된 p2p 네트워크다.  이전에 해결하지 못한 이중 지급 문제를 해결했다.  거래원장은 모든 참여자에게 공개된다.  참여자들은 거래 원장을 조회할수 있고, 규칙에 맞게 작성됐는지 검증할수 있다.  블록체인 데이터를 신뢰할수있는 합의시스템(PoW: proof of work)이 있다.이중지금문제란 어떤 계좌의 잔액이 100원만 남았을때 A에게 100원을 송금하고 B에게도 100원을 송금하는것중앙통제시스템에서 관리한다면 A에게 100원을 송금하자마자 해당 계좌의 잔액은 비었으므로 B에게 송금이 불가하지만중앙통제시스템이 없는 p2p 분산 네트워크는 관리 주체가 없기 때문에 이 문제 해결이 어려움하지만 이논문을 바탕으로 여러개발자들이 비트코인 논문 제안 내용을 연구하여 비트코인 네트워크를 구현암호화폐의 주요 이슈p2p 분산 시스템은 근본적으로 데이터의 일관성, 네트워크의 가용성, 분할내성을 동시에 만족할수 없다.이러한 문제로 인해 기존에 제안된 암호화폐는 묵살 되었고 실생활에 통용될수 없었고 이를 해결하기 위해서는다음과 같은 문제점들이 해결되어야한다.  내가 받은 암호화폐가 진본인지 위조인지 확인가능한가?  내가 받은 암호화폐가 이중 지급 된것이 아닌지 확인가능한가?  내가 보유한 암호화폐의 소유권을 다른 사용자가 인정가능한가?위 문제에 대한 기본적 해결책은 중앙통제 시스템이 검증하고 보관하는것이지만, 중앙화폐시스템은 시스템에 대한 공격을 받으면 산하에 있는 정보가 누출된다는 취약점이 있다.사토시 나카모토는 기존 암호화폐시스템들을 발전시켜 완전히 탈중앙화된 개념을 사용하면서도 위 문제를 해결했다.비트코인은 기존 암호화페 아이디어 종합체  Ecash schema: p2p 네트워크에서 자신이 암호화폐의 소유자임을 ‘증명’ 하고, 다른 사람들이 ‘검증’ 하기 위해 전자 서명을 사용  State machine replication: 각 노드간 데이터 일관성을 보장하기 위한 시스템이다. State는 블록체인의 상태이며 시간에 따라 변한다 1(S1 -&gt; S2 -&gt; S3 -&gt;..). 시간에 따른 상태 변화는 모든 노드가 동일하게 관리해야 한다.  Consensus mechanics: 개별 거래 원장에서 부터 블록체인의 상태까지 모든 과정에 대해 각노드들이 동의할수있는 합의 규칙이다. 이규칙에 의해 전체 상태가 일관되게 유지된다.  HashCash computational puzzle: 합의 규칙에 따라 수학적 퍼즐이 제시되고, 채굴자들은 경쟁적으로 이문제를 푼다. 경쟁에서 이긴 채굴자가 블록을 생성할 권한을 받는다. 이 과정을 통해 신규 암호화화폐가 발행되고, 상태 변화의 일관성이 유지된다.  peer-to-peer: 서버- 클라이언트 구조가 아닌 p2p 구조로 탈중앙화를 이뤘다.  추가설명: A,B가 100원씩 잔액이 있는 상태를 S1이라 가정하면, A가 B에게 50원 송금하면 잔액이 변한다. 이상태를 S2라고 하면 송금행위로 인해 블록체인의 상태는 S1-&gt;S2로 변함블록체인 기술의 의의블록체인의 의의는 안전하지 않은 인터넷망에서 어떠한 중재자 없이 가치 있는 대상을 안전하고 자유롭게 거래 가능하게 하는것  중재자 없는 자유로운 거래 실현          서로 신뢰할수 없는 네트워크 상 안전하게 가치있는 것들을 거래 하게하는 블록체인      단순 화폐교환:비트코인, 화폐 뿐 아니라 계약서, 증명성 교환가능: 이더리움            화폐, 계약서, 증명서 등 디지털 대상의 다양화    사용자 증가에 따른 새로운 가치 창출          사용자들은 매우 편하게 서로의 가치를 교환할수 있게 됨      이 편리함을 바탕으로 사용자들은 점점 많아지고 가치의 교환이 점점더 활발해 짐으로서 새로운 가치 출몰가능성↑      블록체인이 가지고 올 비즈니스 혁신블록체인이 가진 4가지 특성:  Decentralization (탈중앙화)  Transparency (투명성)  Anonymous (익명성)  Immutability (불변성)이 4가지의 특징은 점차 사회를 hyper-connect society로 이끌것이다. 거래에서 발생하는 비용절감과 간소화, 스마트컨트랙으로 계약 내용 이행이 자동화 됨으로써 현재 활발하게 개발되고있는 인공지능 기반 자율주행등 기술에도 블록체인의 기술적 가치가 높다.비트코인 p2p network  각 노드가 동등함  거래 원장관리, 거래승인, 거래내역 검증          거래승인(mining), 거래원장관리(blockchain)        합의 규칙에 따라 각자 업무 수행  전체 노드 50%이상이 정상 데이터가지면 일관성 유지가능비트코인 네트워크 구성원기본적으로 송금(거래내역생성, 트랜잭션 생성), 송금내용확인(검증) 은 모든 노드가 수행  Full blockchain node          채굴자 노드가 블록을 생성한것을 기존 블록체인으로 연결해서 블록체인을 관리      풀 노드가 관리하는 블록체인에는 모든 거래내역(Transaction,TX)애 저장됨      블록체인은 거래 내여들의 집합체이므로 공공거래원장이라고 불림      이 공공 거래장부(블록체인)은 풀노드가 가지고 있고 분산저장      따라서 일부가 잘못되더라도 자체 복원 능력을 가짐        Lightweight node          스마트기기 후에 설명        Miner node          송금내역을 모아서 승인하는 절차 수행      승인이 완료된 트랜잭션들을 모아서 블록을 생성하고 네트워크 전파        3rd party API client          안전성 문제때문에 비트코인 네트워크의 기본 구성원이라 할수없지만 후에 할 실습으로 왜 할수없다 하는지 알아볼 예정      ",
        "url": "/blockchain-1"
    }
    ,
    
    "hash-table": {
        "title": "자료구조 (7) 해시 테이블",
            "author": "pathfinder357",
            "category": "",
            "content": "Hash Table  해시 테이블은 일종의 사전이고, Python 의 dict 자료구조처럼 다음 연산을 빠르게 지원          if(데이터가 key, value 값의 쌍으로 구성                  insert(key, val)     #(key, val)를 해시 테이블에 저장, 같은 키가 있다면 overwirte          remove(key, val)     #(key, val)가 해시 테이블에 있다면 제거(delete)          search(key)          #(key, val)를 찾아 리턴, 없다면 알려줌                          해시 테이블은 보통 정보를 담아 저장할수있는 서랍장 행태로 구현          가장 핵심적인 과정은 각 정보를 몇번째 서랍에 넣을지를 결정하는 것        정보 K(key)가 저장될 서랍장(slot) 번호를 계산하는 함수 f()를 hash func 이라 한다.hash func  만약 key값이 정수가 아니라면?&gt; 실수이거나 문자열이라면?                  (실수, 문자열) key 값을 정수에 대응시키는 prehash함수를 먼저 사용해 변환                    hash 함수로 지정할수 있음                  perpect 해시 함수: 충돌없이 1 - to - 1 매핑하는 해시 함수        c- universal 해시 함수: 서로 임의의 두 key 값 x, y 에대해 prob(f(x) == f(y)= c/size(H))  이 성립하는 해시 함수    (key 값이 숫자일 경우)          Division: f(k) = (k mod p) mod m(p:소수)                  key 값들의 성질이 잘 알려지지 않은 경우                    Multiplication: f(k) = ((ak) mod 2^w) » (w-r)                  a:랜덤값, w =log k, r=log m                    folding: key값들의 digit을 나눠 연산하는 방식                  shift - folding: ex) bank- account k = 1234 - 567 - 601 두개의 digit 씩 나눠 모두  더한다 -&gt; (12+ 34+ 56+ 76+ 01) mod m                    mid - square : key 값을 적당히 연산후 , 그결과의 중간부분을 떼어내 주소로 사용                  m= 1000이고, k= 3121이면, 3121 ^2 = 9740641이되고 중간에 3 digit을 때어낸 주소 406                    Extraction: key 값의 각 파트마다 임의의 digit을 떼어네 연결해 계산                  계좌번호가 1254-387-601이라면, 1254에서 12, 601에서 1을 때어낸후 서로 붙여 121을 만듬                          (key 값이 string 경우)          Additive hash: key[i]의 단순 합      Rotating hash: «, »(비트 쉬프트)연산과 ^(exclusive or) 연산을 반복        좋은 해시 함수란?          되도록 빠르고, 충돌이 되도록 적어야 한다.      충돌 해결 방법  서로 다른 key 값 x, y에 대해 f(x) = f(y)가 된다면 두 키값은 충돌이라함  이와 같은 경우에 두값을 해시 테이블에 저장 방법 즉 충돌 해경방법 필요  open - addressing 과 chaining 두가지 방법이 일반적임a. open addressing: linear probing  삽입 탐색 pseudo code ↓def set(key, val):   i = find_slot(key)      #빈 슬롯이 없는 경우 대책은?   if i == FULL:           #더 큰 테이블이 필요함.      return None   if H[i] is occupied:    #key값이 존재하면 기존 값 수정      H[i].val = val       #val 값 update 후 리턴   else:                   #H[i]가 비어있는 경우, 즉 key가 없다면 새로 지정해야함      H[i].key =key      H[i].val = val   retrun keydef find_slot(key):   i = f(key)   start = i   while (H[i] is occupied) and (H[i].key != key):      i = (i+1) % m      if i == start:          return FULL      return i  삽입 연산: set(key, val)          해시 테이블 H의 각 슬롯에는 하나의 아이템을 저장      아이템(key , val) 쌍으로 정의      key는 아이템들끼리 구분하므로 아이템마다 서로 달라야함      value 는 해당 아이템의 다양한 정보를 의미      key 값을 갖는 아이템이 이미 테이블에 있다면 해당 아이템의 val를 매개변수 val값으로 수정, 없다면 새 아이템(key, val)를 삽입하는 연산      정상적으로 삽입이 이루어지면, key 값을 그대로 리턴하고, 빈테이블에 빈슬롯이 없어 삽입하지 않으면 FULL 리턴      이를 위해 open addressing 방법에 따라 key값을 갖는 아이템을 찾거나 빈슬롯을 찾아 H인덱스를 리턴하는 find_slot(key)함수 필요        find_slot(key)          key 값을 갖는 아이템을 찾아 index를 리턴. 단 해당 슬롯에 아이템 있다면 key 값을 갖는 아이템이며, 슬롯이 비어있다면 해당 아이템이 해시 테이블에 없다는 뜻      만약 key 값을 갖는 슬롯이 존재하지도, 빈슬롯도 없다면 FULL리턴        삭제 psuedo code ↓    def remove(key):  i =find_slot(key)  if H[i] is unoccupied:      return None  j = i  while True:      mark H[i] as unoccupied      while True:          j = (j+1) % m           if H[j] is unoccupied:  # 이동완료              return key          k = f(H[j].key)          if not(i &lt; k &lt;= j or j &lt;i&lt; k or k&lt;=j &lt;i):              break      H[i] = H[j]      i = j        삭제 연산: remove(key)          key 값을 갖는 아이템을 find_slot()을 이용해 찾는다.      H[i]가 비었다면 삭제할 아이템이 실제로 존재 하지않으므로 None 리턴      H[i]가 존재한다면, 이 아이템때문에 밀린 아래쪽의 cluster 들을 연쇄적으로 위로 올려 이동한다      이동한후 성공적인 삭제가 수행되었다는 의미에서 key 값 자체 리턴                  H[i]는 현재 빈슬롯이고, 아래쪽 H[j]에 있는 아이템을 H[i]로 이동할지를 결정해야 함          H[j].key 값의 해시 함수 값을 k 라 하자 즉, k = f(H[j].key)이다          이 키 값이 [i,j]에 있다면 즉, (..i..k..j..)순이라면 H[j]를 H[i]로 옮기면 안됨          왜?? -&gt;                    ",
        "url": "/hash-table"
    }
    ,
    
    "data-queue": {
        "title": "자료구조 (4) 큐",
            "author": "pathfinder357",
            "category": "",
            "content": "QueueFIFO(first-in first-out)규칙의 순차적 자료구조자료를 추가 / 삭제하는 통상적으로 합의한 용어insert -&gt; enqueuedelete -&gt; dequeue이런식으로 작동할려면 어떻게 해야할까?stack은 어디까지 쌓여있는지에 대한 정보 즉 top()에 있는 값의 인덱스만 가지고 작동을 다루었다면queue는 1.enqueue는 차곡차곡 쌓여서 어디까지 쌓여있는지2.dqueue 가장 밑에 있는 다음에 나갈 값이 어디 인덱스가 있는지 즉 두개의 인덱스 이 두개로 문제를 해결.여기서 주의할점은 dequeue를 한다고 해서 실제로 값이 삭제되는 것이 아니고index를 조절하는것일 뿐이다.큐 설계class Queue:    def __init__(self):        self.items = []        self.front_index = 0        self.size =0    def enqueue(self, val):        self.items.append(val)        self.size += 1        def dequeue(self):        if self.front_index == len(self.items):            print('Queue is empty')            return None        else:            x = self.items[self.front_index]            self.front_index += 1            self.size -= 1            self.items.pop(0)            return x    def size(self):        return len(self.size)Josephus Problemfrom stack_queue import Queuedef rullet(n,k):    Q=Queue()    for cnt in range(1, n+1):        Q.enqueue(cnt)    while Q.size !=0:        for i in range(1,k):            Q.enqueue(Q.dequeue())        Q.pop()    return Q.dequeue()",
        "url": "/data-queue"
    }
    ,
    
    "data-array-list": {
        "title": "자료구조 (1) 어레이와 리스트 차이",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     1    2    3    4    5    6    7배열과 리스트일반적인 프로그램 동작 방식A[2]    =      A[2]   +  1(쓰기)  (대입)  (읽기)   (산술)파이썬은 씨언어의 배열의 셀과 다르게 데이터의가 저장된곳의 주소가 저장된다.즉 항상 객체의 주소만 저장하기때문에, 리스트의 셀의 크기를 메모리의 주소를 표현 할수있는 8바이트로 고정하면 된다.모든셀의 크기가 같기 때문에 index에 의해 O(1)시간 접근이 가능하다.C는 배열에 읽기와 쓰기만 적용되지만 파이썬의 리스트는 pop, insert, append등 여러가지 연산이 추가되는 굉장히 편리리스트는 용량을 자동조절(동적배열)ex) def append principle of operation(Pseudo code)def append(A, val):1. if A.capacity == A.n:  #needed to resize!!    a. 더큰 메모리를 가진 리스트 B를 할당하고 B.capacity 와 B.n으로 갱신하자      b. for i in range(A, n):        B[i] = A[i]    c. dispose A    d. A = B2. A[n] = val3. A.n += 1리스트가 가지는 강력한 동작들1.append(val) : #맨 오른쪽(뒤)에 새로운 값 val를 삽입2.A.pop(i): #A[i]값을 지운후 리턴(i의 오른쪽 값들은 왼쪽으로 한칸씩 당겨져 cell의 수 감소)3.A.insert(i ,val) : val 연산( 단 A[i] , A[i+1], .. 값들은 오른쪽으로 한칸씩 이동해 A[i]를 비운후 , val 값 저장)4.A.remove(val) : val값 제거5.A.index(val) : val 값이 처음으로 등장하는 index 리턴6.A.count(val) : val값이 몇번 등장하는 지 횟수를 세어 리턴7.A[i:j] : A[i], ..., A[j-1]까지를 복사해 새로운 리스트 생성하여 리턴(slicing 연산)8.val in A : 맴버십 연산자 -A에 val가 있으면 True, 없으면 False",
        "url": "/data-array-list"
    }
    ,
    
    "data-stack": {
        "title": "자료구조 (3) stack",
            "author": "pathfinder357",
            "category": "",
            "content": "stack__init(self) : 생성함수def __init__(self):        self.items = []ex)S= Stack()init 생성함수안 에있는 객체인 self.itmes = []가 자동으로 생성try &amp; except : try 블록에 있는것을 수행하다가 수행중 에러가 나오면 except에 있는 statment를 수행def pop(self):        try:            return self.items.pop()        except IndexError:            print('stack is empty')print(len(S)) len 을 수행하면 class Stack 안에 있는 len 안에 있는 statement를 수행def __len__(self):        return len(self.items)stack 안에 수행되는 함수들은 전부 O(1) 상수시간안에 돌아가는 자료구조이다.prac) 괄호 맞추기  (2 + 5) * 7 -((3-1)/2+7)  ( ( ) ( ) )  ( ( ) ) ) (    &lt;- 적당한 쌍이 아님-문제:입력: 왼쪽 오른쪽 괄호의 문자열출력: 괄호쌍이 맞춰져있으면 True or False관찰:……(…….)……ex1)( ( ) ( ) )1 2 2 3 3 1왼쪽부터 차례로 읽으면(1) 왼쪽 괄호 ( 왼쪽 괄호가 들어가면 기다려야 하므로 pushex2)( ) )ex3)( ) (알고리즘for p in parseq:    if p =='(' :         S.push(p)    elif p == ')' :         S.pop()  # error 오른쪽이 더 많음    else:         print('Not allowed Symbol)    if len(S) &gt; 0:         return False  # error 왼쪽이 더많음    else:         retun True전체 소스 코드class Stack:    def __init__(self):        self.items = []        def push(self, val):        self.items.append(val)        def pop(self):        try:            return self.items.pop()        except IndexError:            print('stack is empty')        #가장 맨위에 있는 값을 리턴        def top(self):        try:            return self.items[-1]        except IndexError:            print('stack is empty')        #stack의 item수 반환    def size(self):        return len(self.items)        def paresq(self, p):        for p in self.items:            if p == '(':                self.push(p)            elif p == ')':                print('doing pop')                self.pop(p)            else:                print('not allowed Symbol')        if self.__len__() &gt; 0:            return False        else:            return True  postfix 변환기from stack_queue import Stackdef postfix_op(x):    s = Stack()    outstack=[]    priority = {        '*':3,        '/':3,        '+':2,        '-':2,        ')':4,        '(':1    }    for token in x:        if token not in '+-*/()':            outstack.append(token)        elif token == '(':            s.push(token)        elif token == ')':            while s.top() != '(':                outstack.append(s.pop())            s.pop()        else:            if s.is_empty():                s.push(token)            else:                while s.size() &gt; 0:                    if priority[s.top()] &gt;= priority[token]:                        outstack.append(s.pop())                    else:                        break                s.push(token)    while not s.is_empty():        outstack.append(s.pop())    return outstack###postfix 계산기(int일 경우에만)def calc(x):    s2= Stack()    for token in x:        if token not in '+-*/':            s2.push(token)        elif token =='+':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b+a)        elif token =='-':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b-a)        elif token =='*':            a=int(s2.pop())            b=int(s2.pop())            s2.push(b*a)         elif token =='/':            a=int(s2.pop())            b=int(s2.pop())            s2.push(int(b/a))    return int(s2.pop())",
        "url": "/data-stack"
    }
    ,
    
    "data-tree": {
        "title": "자료구조 (6) 트리",
            "author": "pathfinder357",
            "category": "",
            "content": "프로그래밍 자료구조 마지막장 트리.LCRS 트리class Node:    def __init__(self, data):        self.data= data        self.left= None        self.right= None        def __str__(self):        return str(self.data)# __init__을 불러 데이터, 왼쪽 자식, 오른쪽 형제를 초기화하고 __str__을 사용해서 반환된 문자열 표현class Tree:    def __init__(self):        self.root = None    def preorderTraversal(self, node):        print(node, end='')         if not node.left == None :             self.preorderTraversal(node.left) #left_node가 비어있지 않으면 left_node 호출         if not node.right == None :             self.preorderTraversal(node.right) #right_node가 비어있지 않으면 자기호출    def inorderTraversal(self, node):        if not node.left == None : self.inorderTraversal(node.left)        print(node, end='')        if not node.right == None : self.inorderTraversal(node.right)        def postorderTraversal(self, node):        if not node.left == None : self.postorderTraversal(node.left)        if not node.right == None : self.postorderTraversal(node.right)        print(node, end='')    def makeRoot(self, node, left_node, right_node):        if self.root ==None:            self.root=node        node.left=left_node        node.right=right_nodeif __name__==\"__main__\":    node =[]    node.append(Node('-'))     node.append(Node('*'))     node.append(Node('/'))     node.append(Node('A'))    node.append(Node('B'))    node.append(Node('C'))    node.append(Node('D'))     m_tree =Tree()    for i in range(int(len(node)/2)):        m_tree.makeRoot(node[i],node[i*2+1],node[i*2+2])    print(      '전위 순회: ',end=''); m_tree.preorderTraversal(m_tree.root)    print('\\n'+ '중위 순회: ',end=''); m_tree.inorderTraversal(m_tree.root)    print('\\n'+ '후위 순회: ',end=''); m_tree.postorderTraversal(m_tree.root)    이진트리class Node:    def __init__(self,data):        self.data = data        self.left = None        self.right= None        self.is_thread_right = None    def __str__(self):        return str(self.data)class ThreadTree:    def __init__(self):        self.root = None        def inorderTraversal(self, node):        while not node.left ==None:            node = node.left        print(node, end='')        while True:            node = self.findThread(node)            print(node, end='')            if node.right == None:                break    def findThread(self, node):        pre_node = node        node = node.right        if node == None:            return node        if pre_node.is_thread_right:            return node        while not node.left == None:            node = node.left        return node    def makeRoot(self, node, left_node, right_node, thread):        if self.root == None:            self.root = node        node.left = left_node        node.right= right_node        node.is_thread_right = threadif __name__ == \"__main__\":    node =[]    node.append(Node('-'))    node.append(Node('*'))    node.append(Node('/'))    node.append(Node('A'))    node.append(Node('B'))    node.append(Node('C'))    node.append(Node('D'))    m_tree = ThreadTree()    for i in range(int(len(node)/2)):        m_tree.makeRoot(node[i],node[i*2+1],node[i*2+2],False)    m_tree.makeRoot(node[3],None, None, True)    m_tree.makeRoot(node[4],None, None, True)    m_tree.makeRoot(node[5],None, None, True)    node[3].right =node[1]    node[4].right= node[0]    node[5].right= node[2]    print('중위 순회: ', end='' ) ; m_tree.inorderTraversal(m_tree.root) 수식 트리class Node:    def __init__(self,data):        self.data=data        self.left=None        self.right=None    def __str__(self):        return str(self.data)class Express_Tree:    def __init__(self):        self.root =None    def makeRoot(self, node, left_node, right_node):        if self.root == None : self.root=node        node.left= left_node        node.right = right_node    def preorderTraversal(self, node):        print(node, end='')        if not node.left == None : self.preorderTraversal(node.left)        if not node.right == None : self.preorderTraversal(node.right)    def inorderTraversal(self, node):        if not node.left == None : self.inorderTraversal(node.left)        print(node, end='')        if not node.right == None : self.inorderTraversal(node.right)    def postorderTraversal(self, node):        if not node.left == None : self.postorderTraversal(node.left)        if not node.right == None : self.postorderTraversal(node.right)        print(node, end='')class expression:    def switch(self, arg):        self.case_name = 'case_' + str(arg)        self.case= getattr(self, self.case_name, lambda: )if __name__ == \"__main__\":    node =[]    node.append(Node('/'))    node.append(Node('*'))    node.append(Node('7'))    node.append(Node('1'))    node.append(Node('-'))    node.append(Node('5'))    node.append(Node('2'))분리집합 트리class DisjoinSet:    def __init__(self, n):        self.data = [-1 for _ in range(n)]        self.size = n    def find(self, index):        value= self.data[index]        if value &lt;0:            return index                return self.find(value)    def union(self, x, y):        x = self.find(x)        y = self.find(y)        if x == y:            return                if self.data[x] &lt; self.data[y]:            self.data[x] += self.data[y]            self.data[y] = x        else:            self.data[y] += self.data[x]            self.data[x] = y                self.size -= 1disjoint = DisjoinSet(10)disjoint.union(0,1)disjoint.union(1,2)disjoint.union(2,3)disjoint.union(4,5)disjoint.union(5,6)disjoint.union(6,7)disjoint.union(8,9)print(disjoint.data)print(disjoint.size) ",
        "url": "/data-Tree"
    }
    ,
    
    "data-list": {
        "title": "자료구조 (5) 링크드리스트",
            "author": "pathfinder357",
            "category": "",
            "content": "목록형 자료구조인 리스트를 통해 자료구조의 기초를 다질것입니다.링크드 리스트링크드 리스트는 한방향 리스트와 양방향 리스트가 있다.1.링크드리스트는 파이썬의 리스트와 이름만 비슷하지 다른 개념이다.      파이썬의 리스트는 C의 array와 유사한 개념으로 index를 통해 접근하고 수정한다.        링크드 리스트는 노드가 링크에 의해 기차처럼 연결된 순차 자료구조로 링크를 따라 원하는 노드의 데이터를 접근하고 수정한다.  2.노드: 실제 값을 위한 data정보(보통 key값을 저장)와 인접노드를 연결하는 link로 구성class Node:    def __init__(self, key=None):        self.key = None        self.next =None          노드는 자료와 다음 노드를 가르키는 참조값으로 구성 됩니다.3.한방향 링크드 리스트구현하고자 하는 방식노드 생성(structure) -&gt; 노드 추가-&gt; 노드 탐색-&gt; 노드 삭제-&gt; 노드 삽입-&gt;노드수 세기class SLL:    def __init__(self):        self.head =None        self.size = 0    def __iter__(self):        v = self.head        while v != None:            yield v        v = v.next    def __str__(self):        return \"-&gt;\".join(str(v) for v in self)여기서 iterator &amp; generator 개념에 대해서 잠깐 짚고 가보자iterator란?  리스트, 집합, 딕셔너리와 같은 타입이나, 문자열은 for -in 구문을 통해서 “반복적”으로 하나씩 데이터를 꺼내서 처리할수있다.                  이와 같이 여러개의 데이터를 포함한 타입중에서 반복적으로 하나하나 꺼내어 처리가능한 컬랙션이나sequence 들을 순환가능(iterable) 객체라고 한다.                    iterator는 next()함수를 구현한 객체를 말하며 next()함수는 순환가능한 객체의 다음 원소 반환                  파이썬의 iterable 형: list, dict, set, bytes, tuple, range        iter()함수: iterable 형 객체를 iterator 객체로 만드는 파이썬 내장함수    next() 함수를 이용해서 iterator 객체의 다음요소를 얻는데 만약 더이상 가져올 객체가없을경우 StopIteration 예외를 발생시킨다.generator 란?  제너레이터 객체는 모든 값을 메모리에 올려두고 이용하는 것이 아니라 필요할 때마다 생성해서 반환하는 일을함ex)my_generator = (x for x in range(1,4))for n in my_generator:    print(n)123type(my_generator)&lt;class generator&gt;이와같이 반복자와 동일한 일을 하는것처럼 보이지만 여기에서 생성된 1,2,3을 미리 메모리에 만드는것이 아니라 for문에 필요로 할때마다 my_generator로 부터 받아오며 메모리에서 보관하지 않는 점이다. 이를 lazy evaluation이라 함  yield                  일반적인 함수의 return문과 유사하지만 제너레이터를 반환한다는 점에서 return과 차이가 있다.                    여기서 return 문과 yield 개념에 대해서 정리해보자 확실한 비교를 위해서                    return 은 로컬변수로서 함수가 값을 반환할때 사라진다.                    yield 은 로컬변수가 함수를 빠져나올때 throw away 한후에도 값을 그대로 지님즉 함수를 완전히 끝내는게 아니라 필요할때마다 돌려주는 것이다 즉 함수를 실행하면서 바깥에다 값을 던지는것                    yield 바로 밑의 sentence 를 실행                    주의사항: 제너레이터는 실행할때 함수의 몸체를 실행하는것이 아니라, 제너레이터 함수가 가진 객체를 반환하는 일을한다.                    제너레이터는 한번 생성해서 반환한 객체를 보관하지 않기때문에 이전의 코드를 실행한수 추가한 코들르 실행하면 아무런 객체도 출력되지 않음                    제너레이터는 한번 실행하면 아무것도 반환하지않음            class Node:    def __init__(self, data, next=None):        self.data = data        self.next = nextclass SList:    def __init__(self):        self.head = Node(next)        self.size = 0            def listSize(self):        return self.size        def is_empty(self):        if self.size != 0:            return False        else:            return True            def selectNode(self, idx):        if idx &gt;= self.size:            print(\"Index Error\")            return None        if idx == 0:            return self.head        else:            tail = self.head            for cnt in range(idx):                tail = tail.next            return tail            def appendleft(self, value):        if self.is_empty():            self.head = Node(value)        else:            self.head = Node(value, self.head)        self.size += 1        def append(self, value):        if self.is_empty():            self.head = Node(value)            self.size += 1        else:            tail = self.head            while tail.next != None:                tail = tail.next            newtail = Node(value)            tail.next = newtail            self.size += 1            def insert(self, value, idx):        if self.is_empty():            self.head = Node(value)            self.size += 1        elif idx == 0:            self.head = Node(value, self.head)            self.size += 1        else:            tail = self.selectNode(idx-1)            if tail == None:                return            newNode = Node(value)            tmp = tail.next            tail.next = newNode            newNode.next = tmp            self.size += 1            def delete(self, idx):        if self.is_empty():            print('Underflow: Empty Linked List Error')            return        elif idx &gt;= self.size:            print('Overflow: Index Error')            return        elif idx == 0:            tail = self.head            self.head = tail.next            del(tail)            self.size -= 1        else:            tail = self.selectNode(idx-1)            deltarget = tail.next            tail.next = tail.next.next            del(deltarget)            self.size -= 1                def printlist(self):        target = self.head        while target:            if target.next != None:                print(target.data, '-&gt; ', end='')                target = target.next            else:                print(target.data)                target = target.next공부하던 와중 가장 햇갈린 부분 삽입 부분에서 밑의 코드    tail= self.head    while tail.next != None:        tail = tail.next    newtail=Node(value)    tail.next = newtail    self.size +=1이부분은 노드추가 함수 부분중 일부분인데 노드 추가하기 위해서 꼬리 노드에 도달하면 마지막 노드의 .next에 새로운노드의 주소를 저장하고 size를 추가시키는 부분인데while 반복문중에서 tail = tail.next 이부분이 이해가 잘 가지가 않았다. 하지만 공부했던 것을 다시 생각해보니 좌변에 있는 변수는 우변에 있는 어떤것에 대한 주소의 별칭일 뿐이다.즉 tail =tail.next는 tail이 가르키는 곳이 tail.next가 가르키는 곳으로 바뀌었다는 뜻인것이다.splice 연산def splice(self, a, b, x):  조건1: a -&gt;.... -&gt; b  조건2: a와 b 사이에 (Head노드 X, x노드존재 X) cut될경우 다른노드로 올기다는뜻이됨   조건3: 조건 1,2가 유지 된다면 a~b사이만큼을 노드를 컷  조건4: x-&gt;x.next 사이에 붙여넣기  ",
        "url": "/data-list"
    }
    ,
    
    "data-basic": {
        "title": "자료구조 (2) 순차적자료구조",
            "author": "pathfinder357",
            "category": "",
            "content": "순차적 자료구조(1) 배열, 리스트인덱스로 임의 원소를 접근  연산자 []  삽입(append, insert)  삭제(pop, remove)(2) stack, queue, dequeue  제한된 접근(삽입, 삭제)  접근만 허용  배열과 리스트는 인덱스만 알면 삭제 삽입이 가능하지만 스택, 큐는 제한된 것만 활용가능＊ 스택 접근 방식  LIFO(last in first out)밑에서부터 차곡차곡제한된 연산만 사용하는 자료구조는 굉장히 많다 (ex: )＊ 큐 접근방식  FIFO(first in fist out, 선착순)밑에서부터 차곡차곡＊ dequeue 접근방식  stack + queue(3) Linked List독립적으로 저장되어 있는 노드에 다음값에 대해서 알고있는 링크를연결 하는 것      각각의 노드에 자기 자신의 val + self.next를 가진다.        각자의 값들이 연속되어 있지 않은 곳에 저장되어 있고 다음 노드의 링크를 가지고있는것(idx로 접근 할수가없지만 함수로 가능케 할순있음)  ",
        "url": "/data-basic"
    }
    ,
    
    "algo-control": {
        "title": "second",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     first    second컨트롤# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           yujunchoi  avatar:         photo.jpg  bio:            &quot;SSU computer science lab&quot;  email:          nsa01775@naver.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://pathfinder357.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: CYJ practice blog# 자신의 blog title.description: 공부내용 정리 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.png# favicon으로 사용할 imageproduction_url: https://pathfinder357.github.io# 최종적으로 blog가 운영될 urlsource_url: https://github.com/pathfinder/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: pathfinder357repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ../[GitHubPage]/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera  - _posts/python  - _posts/typescript  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy",
        "url": "/algo-control"
    }
    ,
    
    "algo-basic": {
        "title": "first",
            "author": "pathfinder357",
            "category": "",
            "content": "목차.     first    second알고리즘알고리즘은 문제의 입력을 수학적이고 논리적으로 정의된 연산과정을 거쳐 원하는 출력을 계산하는 절차이고, 이절차를 c나 python과 같은 언어로 표현하는 프로그램또는 코드가 된다.입력은 (array(C) 또는 list(Python)), 연결리스트, 트리, 해시테이블, 그래프와 같은 자료의접근과 수정이 빠른 자료구조에 저장된다.최초의 알고리즘인 GCD를 재귀를 이용하여 구현한 코드를 짜보았다.def algo_gcd(a,b):while a*b != 0:if a&gt;b:a = a - balgo_gcd(b ,a % b)else:b = b- aalgo_gcd(a, b % a)        return a + bprint(algo_gcd(22,13))",
        "url": "/algo-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://pathfinder357.github.io/">Pathfinder practice blog</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search Pathfinder practice blog</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
